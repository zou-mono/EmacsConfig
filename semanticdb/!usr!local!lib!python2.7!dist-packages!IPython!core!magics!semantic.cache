;; Object magics/
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "magics/"
  :tables
  (list
    (semanticdb-table "execution.py"
      :major-mode 'python-mode
      :tags 
        '( ("\"\"\"Implementation of execution-related magic functions.\"\"\"" code nil nil [25 83])
            ("__future__" include nil nil [187 224])
            ("ast" include nil nil [226 236])
            ("bdb" include nil nil [237 247])
            ("gc" include nil nil [248 257])
            ("itertools" include nil nil [258 274])
            ("os" include nil nil [275 284])
            ("sys" include nil nil [285 295])
            ("time" include nil nil [296 307])
            ("timeit" include nil nil [308 321])
            ("pdb" include nil nil [322 345])
            ("try" code nil nil [381 620])
            ("IPython.core" include nil nil [621 664])
            ("IPython.core" include nil nil [665 705])
            ("IPython.core" include nil nil [706 735])
            ("IPython.core.error" include nil nil [736 777])
            ("IPython.core.macro" include nil nil [778 814])
            ("" code nil nil [846 968])
            ("IPython.testing.skipdoctest" include nil nil [969 1021])
            ("IPython.utils" include nil nil [1022 1057])
            ("IPython.utils.py3compat" include nil nil [1058 1121])
            ("IPython.utils.contexts" include nil nil [1122 1170])
            ("IPython.utils.capture" include nil nil [1171 1219])
            ("IPython.utils.ipstruct" include nil nil [1220 1261])
            ("IPython.utils.module_paths" include nil nil [1262 1309])
            ("IPython.utils.path" include nil nil [1310 1385])
            ("IPython.utils.timing" include nil nil [1386 1432])
            ("IPython.utils.warn" include nil nil [1433 1475])
            ("if" code nil nil [1477 1553])
            ("TimeitResult" type
               (:documentation "
    Object returned by the timeit magic with info about the run.

    Contain the following attributes :

    loops: (int) number of loop done per measurement
    repeat: (int) number of time the mesurement has been repeated
    best: (float) best execusion time / number
    all_runs: (list of float) execusion time of each run (in s)
    compile_time: (float) time of statement compilation (s)

    "
                :superclasses ("object")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("self" variable nil (reparse-symbol indented_block_body) [2282 2300])
                            ("self" variable nil (reparse-symbol indented_block_body) [2309 2329])
                            ("self" variable nil (reparse-symbol indented_block_body) [2338 2354])
                            ("self" variable nil (reparse-symbol indented_block_body) [2363 2381])
                            ("self" variable nil (reparse-symbol indented_block_body) [2390 2414])
                            ("self" variable nil (reparse-symbol indented_block_body) [2423 2455])
                            ("self" variable nil (reparse-symbol indented_block_body) [2464 2491]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [2204 2208])
                            ("loops" variable nil (reparse-symbol function_parameters) [2210 2215])
                            ("repeat" variable nil (reparse-symbol function_parameters) [2217 2223])
                            ("best" variable nil (reparse-symbol function_parameters) [2225 2229])
                            ("worst" variable nil (reparse-symbol function_parameters) [2231 2236])
                            ("all_runs" variable nil (reparse-symbol function_parameters) [2238 2246])
                            ("compile_time" variable nil (reparse-symbol function_parameters) [2248 2260])
                            ("precision" variable nil (reparse-symbol function_parameters) [2262 2271]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [2191 2492])
                    ("_repr_pretty_" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [2515 2519])
                            ("p" variable nil (reparse-symbol function_parameters) [2521 2522])
                            ("cycle" variable nil (reparse-symbol function_parameters) [2525 2530]))                          )
                        (reparse-symbol indented_block_body) [2497 3003]))                  
                :type "class")
                nil [1745 3003])
            ("TimeitTemplateFiller" type
               (:documentation "Fill in the AST template for timing execution.

    This is quite closely tied to the template definition, which is in
    :meth:`ExecutionMagics.timeit`.
    "
                :superclasses ("ast.NodeTransformer")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("self" variable nil (reparse-symbol indented_block_body) [3277 3303])
                            ("self" variable nil (reparse-symbol indented_block_body) [3312 3336]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [3241 3245])
                            ("ast_setup" variable nil (reparse-symbol function_parameters) [3247 3256])
                            ("ast_stmt" variable nil (reparse-symbol function_parameters) [3258 3266]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [3228 3337])
                    ("visit_FunctionDef" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [3364 3368])
                            ("node" variable nil (reparse-symbol function_parameters) [3370 3374]))                          )
                        (reparse-symbol indented_block_body) [3342 3550])
                    ("visit_For" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [3569 3573])
                            ("node" variable nil (reparse-symbol function_parameters) [3575 3579]))                          )
                        (reparse-symbol indented_block_body) [3555 3769]))                  
                :type "class")
                nil [3005 3769])
            ("Timer" type
               (:documentation "Timer class that explicitly uses self.inner
    
    which is an undocumented implementation detail of CPython,
    not shared by PyPy.
    "
                :superclasses ("timeit.Timer")
                :members 
                  ( ("timeit" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [4009 4013])
                            ("number" variable nil (reparse-symbol function_parameters) [4015 4021]))                          
                        :documentation "Time 'number' executions of the main statement.

        To be precise, this executes the setup statement once, and
        then returns the time it takes to execute the main statement
        a number of times, as a float measured in seconds.  The
        argument is the number of times through the loop, defaulting
        to one million.  The main statement, the setup statement and
        the timer function to be used are passed to the constructor.
        ")
                        (reparse-symbol indented_block_body) [3998 4771]))                  
                :type "class")
                nil [3771 4771])
            ("ExecutionMagics" type
               (:documentation "Magics related to code execution, debugging, profiling, etc.

    "
                :superclasses ("Magics")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("super" code nil (reparse-symbol indented_block_body) [4935 4979])
                            ("if" code nil (reparse-symbol indented_block_body) [4988 5060])
                            ("self" variable nil (reparse-symbol indented_block_body) [5137 5163]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [4913 4917])
                            ("shell" variable nil (reparse-symbol function_parameters) [4919 4924]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [4900 5164])
                    ("profile_missing_notice" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [5196 5200])
                            ("args" variable nil (reparse-symbol function_parameters) [5202 5207])
                            ("kwargs" variable nil (reparse-symbol function_parameters) [5209 5217]))                          )
                        (reparse-symbol indented_block_body) [5169 5438])
                    ("prun" function
                       (:parent "dummy"
                        :decorators 
                          ( ("skip_doctest" function (:type "decorator") nil nil)
                            ("line_cell_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [5491 5495])
                            ("parameter_s" variable nil (reparse-symbol function_parameters) [5497 5508])
                            ("cell" variable nil (reparse-symbol function_parameters) [5513 5517]))                          
                        :documentation "Run a statement through the python code profiler.

        Usage, in line mode:
          %prun [options] statement

        Usage, in cell mode:
          %%prun [options] [statement]
          code...
          code...

        In cell mode, the additional code lines are appended to the (possibly
        empty) statement in the first line.  Cell mode allows you to easily
        profile multiline blocks without having to put them in a separate
        function.

        The given statement (which doesn't require quote marks) is run via the
        python profiler in a manner similar to the profile.run() function.
        Namespaces are internally managed to work correctly; profile.run
        cannot be used in IPython because it makes certain assumptions about
        namespaces which do not hold under IPython.

        Options:

        -l <limit>
          you can place restrictions on what or how much of the
          profile gets printed. The limit value can be:

             * A string: only information for function names containing this string
               is printed.

             * An integer: only these many lines are printed.

             * A float (between 0 and 1): this fraction of the report is printed
               (for example, use a limit of 0.4 to see the topmost 40% only).

          You can combine several limits with repeated use of the option. For
          example, ``-l __init__ -l 5`` will print only the topmost 5 lines of
          information about class constructors.

        -r
          return the pstats.Stats object generated by the profiling. This
          object has all the information about the profile in it, and you can
          later use it for further analysis or in other functions.

        -s <key>
          sort profile by given key. You can provide more than one key
          by using the option several times: '-s key1 -s key2 -s key3...'. The
          default sorting key is 'time'.

          The following is copied verbatim from the profile documentation
          referenced below:

          When more than one key is provided, additional keys are used as
          secondary criteria when the there is equality in all keys selected
          before them.

          Abbreviations can be used for any key names, as long as the
          abbreviation is unambiguous.  The following are the keys currently
          defined:

          ============  =====================
          Valid Arg     Meaning
          ============  =====================
          \"calls\"       call count
          \"cumulative\"  cumulative time
          \"file\"        file name
          \"module\"      file name
          \"pcalls\"      primitive call count
          \"line\"        line number
          \"name\"        function name
          \"nfl\"         name/file/line
          \"stdname\"     standard name
          \"time\"        internal time
          ============  =====================

          Note that all sorts on statistics are in descending order (placing
          most time consuming items first), where as name, file, and line number
          searches are in ascending order (i.e., alphabetical). The subtle
          distinction between \"nfl\" and \"stdname\" is that the standard name is a
          sort of the name as printed, which means that the embedded line
          numbers get compared in an odd way.  For example, lines 3, 20, and 40
          would (if the file names were the same) appear in the string order
          \"20\" \"3\" and \"40\".  In contrast, \"nfl\" does a numeric compare of the
          line numbers.  In fact, sort_stats(\"nfl\") is the same as
          sort_stats(\"name\", \"file\", \"line\").

        -T <filename>
          save profile results as shown on screen to a text
          file. The profile is still shown on screen.

        -D <filename>
          save (via dump_stats) profile statistics to given
          filename. This data is in a format understood by the pstats module, and
          is generated by a call to the dump_stats() method of profile
          objects. The profile is still shown on screen.

        -q
          suppress output to the pager.  Best used with -T and/or -D above.

        If you want to run complete programs under the profiler's control, use
        ``%run -p [prof_opts] filename.py [args to program]`` where prof_opts
        contains profiler specific options as described here.

        You can read the complete documentation for the profile module with::

          In [1]: import profile; profile.help()
        ")
                        (reparse-symbol indented_block_body) [5443 10458])
                    ("_run_with_profiler" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [10486 10490])
                            ("code" variable nil (reparse-symbol function_parameters) [10492 10496])
                            ("opts" variable nil (reparse-symbol function_parameters) [10498 10502])
                            ("namespace" variable nil (reparse-symbol function_parameters) [10504 10513]))                          
                        :documentation "
        Run `code` with profiler.  Used by ``%prun`` and ``%run -p``.

        Parameters
        ----------
        code : str
            Code to be executed.
        opts : Struct
            Options parsed by `self.parse_options`.
        namespace : dict
            A dictionary for Python namespace (e.g., `self.shell.user_ns`).

        ")
                        (reparse-symbol indented_block_body) [10463 12752])
                    ("pdb" function
                       (:parent "dummy"
                        :decorators 
                          ( ("line_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [12781 12785])
                            ("parameter_s" variable nil (reparse-symbol function_parameters) [12787 12798]))                          
                        :documentation "Control the automatic calling of the pdb interactive debugger.

        Call as '%pdb on', '%pdb 1', '%pdb off' or '%pdb 0'. If called without
        argument it works as a toggle.

        When an exception is triggered, IPython can optionally call the
        interactive pdb debugger after the traceback printout. %pdb toggles
        this feature on and off.

        The initial state of this feature is set in your configuration
        file (the option is ``InteractiveShell.pdb``).

        If you want to just activate the debugger AFTER an exception has fired,
        without having to type '%pdb on' and rerunning your code, you can use
        the %debug magic.")
                        (reparse-symbol indented_block_body) [12757 14015])
                    ("" code nil (reparse-symbol indented_block_body) [14070 14072])
                    ("" code nil (reparse-symbol indented_block_body) [14102 14221])
                    ("" code nil (reparse-symbol indented_block_body) [14251 14389])
                    ("debug" function
                       (:parent "dummy"
                        :decorators 
                          ( ("line_cell_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [14425 14429])
                            ("line" variable nil (reparse-symbol function_parameters) [14431 14435])
                            ("cell" variable nil (reparse-symbol function_parameters) [14440 14444]))                          
                        :documentation "Activate the interactive debugger.

        This magic command support two ways of activating debugger.
        One is to activate debugger before executing code.  This way, you
        can set a break point, to step through the code from the point.
        You can use this mode by giving statements to execute and optionally
        a breakpoint.

        The other one is to activate debugger in post-mortem mode.  You can
        activate this mode simply running %debug without any argument.
        If an exception has just occurred, this lets you inspect its stack
        frames interactively.  Note that this will always work only on the last
        traceback that occurred, so you must call this quickly after an
        exception that you wish to inspect has fired, because if another one
        occurs, it clobbers the previous one.

        If you want IPython to automatically do this on every exception, see
        the %pdb magic for more details.
        ")
                        (reparse-symbol indented_block_body) [14394 15773])
                    ("_debug_post_mortem" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [15801 15805]))                          )
                        (reparse-symbol indented_block_body) [15778 15848])
                    ("_debug_exec" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [15869 15873])
                            ("code" variable nil (reparse-symbol function_parameters) [15875 15879])
                            ("breakpoint" variable nil (reparse-symbol function_parameters) [15881 15891]))                          )
                        (reparse-symbol indented_block_body) [15853 16149])
                    ("tb" function
                       (:parent "dummy"
                        :decorators 
                          ( ("line_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [16177 16181])
                            ("s" variable nil (reparse-symbol function_parameters) [16183 16184]))                          
                        :documentation "Print the last traceback with the currently active exception mode.

        See %xmode for changing exception reporting modes.")
                        (reparse-symbol indented_block_body) [16154 16363])
                    ("run" function
                       (:parent "dummy"
                        :decorators 
                          ( ("skip_doctest" function (:type "decorator") nil nil)
                            ("line_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [16410 16414])
                            ("parameter_s" variable nil (reparse-symbol function_parameters) [16416 16427])
                            ("runner" variable nil (reparse-symbol function_parameters) [16432 16438])
                            ("file_finder" variable nil (reparse-symbol function_parameters) [16463 16474]))                          
                        :documentation "Run the named file inside IPython as a program.

        Usage::
        
          %run [-n -i -e -G]
               [( -t [-N<N>] | -d [-b<N>] | -p [profile options] )]
               ( -m mod | file ) [args]

        Parameters after the filename are passed as command-line arguments to
        the program (put in sys.argv). Then, control returns to IPython's
        prompt.

        This is similar to running at a system prompt ``python file args``,
        but with the advantage of giving you IPython's tracebacks, and of
        loading all variables into your interactive namespace for further use
        (unless -p is used, see below).

        The file is executed in a namespace initially consisting only of
        ``__name__=='__main__'`` and sys.argv constructed as indicated. It thus
        sees its environment as if it were being run as a stand-alone program
        (except for sharing global objects such as previously imported
        modules). But after execution, the IPython interactive namespace gets
        updated with all variables defined in the program (except for __name__
        and sys.argv). This allows for very convenient loading of code for
        interactive work, while giving each program a 'clean sheet' to run in.

        Arguments are expanded using shell-like glob match.  Patterns
        '*', '?', '[seq]' and '[!seq]' can be used.  Additionally,
        tilde '~' will be expanded into user's home directory.  Unlike
        real shells, quotation does not suppress expansions.  Use
        *two* back slashes (e.g. ``\\\\\\\\*``) to suppress expansions.
        To completely disable these expansions, you can use -G flag.

        Options:

        -n
          __name__ is NOT set to '__main__', but to the running file's name
          without extension (as python does under import).  This allows running
          scripts and reloading the definitions in them without calling code
          protected by an ``if __name__ == \"__main__\"`` clause.

        -i
          run the file in IPython's namespace instead of an empty one. This
          is useful if you are experimenting with code written in a text editor
          which depends on variables defined interactively.

        -e
          ignore sys.exit() calls or SystemExit exceptions in the script
          being run.  This is particularly useful if IPython is being used to
          run unittests, which always exit with a sys.exit() call.  In such
          cases you are interested in the output of the test results, not in
          seeing a traceback of the unittest module.

        -t
          print timing information at the end of the run.  IPython will give
          you an estimated CPU time consumption for your script, which under
          Unix uses the resource module to avoid the wraparound problems of
          time.clock().  Under Unix, an estimate of time spent on system tasks
          is also given (for Windows platforms this is reported as 0.0).

        If -t is given, an additional ``-N<N>`` option can be given, where <N>
        must be an integer indicating how many times you want the script to
        run.  The final timing report will include total and per run results.

        For example (testing the script uniq_stable.py)::

            In [1]: run -t uniq_stable

            IPython CPU timings (estimated):
              User  :    0.19597 s.
              System:        0.0 s.

            In [2]: run -t -N5 uniq_stable

            IPython CPU timings (estimated):
            Total runs performed: 5
              Times :      Total       Per run
              User  :   0.910862 s,  0.1821724 s.
              System:        0.0 s,        0.0 s.

        -d
          run your program under the control of pdb, the Python debugger.
          This allows you to execute your program step by step, watch variables,
          etc.  Internally, what IPython does is similar to calling::

              pdb.run('execfile(\"YOURFILENAME\")')

          with a breakpoint set on line 1 of your file.  You can change the line
          number for this automatic breakpoint to be <N> by using the -bN option
          (where N must be an integer). For example::

              %run -d -b40 myscript

          will set the first breakpoint at line 40 in myscript.py.  Note that
          the first breakpoint must be set on a line which actually does
          something (not a comment or docstring) for it to stop execution.

          Or you can specify a breakpoint in a different file::

              %run -d -b myotherfile.py:20 myscript

          When the pdb debugger starts, you will see a (Pdb) prompt.  You must
          first enter 'c' (without quotes) to start execution up to the first
          breakpoint.

          Entering 'help' gives information about the use of the debugger.  You
          can easily see pdb's full documentation with \"import pdb;pdb.help()\"
          at a prompt.

        -p
          run program under the control of the Python profiler module (which
          prints a detailed report of execution times, function calls, etc).

          You can pass other options after -p which affect the behavior of the
          profiler itself. See the docs for %prun for details.

          In this mode, the program's variables do NOT propagate back to the
          IPython interactive namespace (because they remain in the namespace
          where the profiler executes them).

          Internally this triggers a call to %prun, see its documentation for
          details on the options available specifically for profiling.

        There is one special usage for which the text above doesn't apply:
        if the filename ends with .ipy[nb], the file is run as ipython script,
        just as if the commands were written on IPython prompt.

        -m
          specify module name to load instead of script path. Similar to
          the -m option for the python interpreter. Use this option last if you
          want to combine with other %run options. Unlike the python interpreter
          only source modules are allowed no .pyc or .pyo files.
          For example::

              %run -m example

          will run the example module.

        -G
          disable shell-like glob expansion of arguments.

        ")
                        (reparse-symbol indented_block_body) [16368 30455])
                    ("_run_with_debugger" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [30483 30487])
                            ("code" variable nil (reparse-symbol function_parameters) [30489 30493])
                            ("code_ns" variable nil (reparse-symbol function_parameters) [30495 30502])
                            ("filename" variable nil (reparse-symbol function_parameters) [30504 30512])
                            ("bp_line" variable nil (reparse-symbol function_parameters) [30546 30553])
                            ("bp_file" variable nil (reparse-symbol function_parameters) [30560 30567]))                          
                        :documentation "
        Run `code` in debugger with a break point.

        Parameters
        ----------
        code : str
            Code to execute.
        code_ns : dict
            A namespace in which `code` is executed.
        filename : str
            `code` is ran as if it is in `filename`.
        bp_line : int, optional
            Line number of the break point.
        bp_file : str, optional
            Path to the file in which break point is specified.
            `filename` is used if not given.

        Raises
        ------
        UsageError
            If the break point given by `bp_line` is not valid.

        ")
                        (reparse-symbol indented_block_body) [30460 33476])
                    ("_run_with_timing" function
                       (:typemodifiers ("static")
                        :decorators 
                          ( ("staticmethod" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("run" variable nil (reparse-symbol function_parameters) [33520 33523])
                            ("nruns" variable nil (reparse-symbol function_parameters) [33525 33530]))                          
                        :documentation "
        Run function `run` and print timing information.

        Parameters
        ----------
        run : callable
            Any callable object which takes no argument.
        nruns : int
            Number of times to execute `run`.

        ")
                        (reparse-symbol indented_block_body) [33481 34776])
                    ("timeit" function
                       (:parent "dummy"
                        :decorators 
                          ( ("skip_doctest" function (:type "decorator") nil nil)
                            ("line_cell_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [34831 34835])
                            ("line" variable nil (reparse-symbol function_parameters) [34837 34841])
                            ("cell" variable nil (reparse-symbol function_parameters) [34846 34850]))                          
                        :documentation "Time execution of a Python statement or expression

        Usage, in line mode:
          %timeit [-n<N> -r<R> [-t|-c] -q -p<P> -o] statement
        or in cell mode:
          %%timeit [-n<N> -r<R> [-t|-c] -q -p<P> -o] setup_code
          code
          code...

        Time execution of a Python statement or expression using the timeit
        module.  This function can be used both as a line and cell magic:

        - In line mode you can time a single-line statement (though multiple
          ones can be chained with using semicolons).

        - In cell mode, the statement in the first line is used as setup code
          (executed but not timed) and the body of the cell is timed.  The cell
          body has access to any variables created in the setup code.

        Options:
        -n<N>: execute the given statement <N> times in a loop. If this value
        is not given, a fitting value is chosen.

        -r<R>: repeat the loop iteration <R> times and take the best result.
        Default: 3

        -t: use time.time to measure the time, which is the default on Unix.
        This function measures wall time.

        -c: use time.clock to measure the time, which is the default on
        Windows and measures wall time. On Unix, resource.getrusage is used
        instead and returns the CPU user time.

        -p<P>: use a precision of <P> digits to display the timing result.
        Default: 3

        -q: Quiet, do not print result.

        -o: return a TimeitResult that can be stored in a variable to inspect
            the result in more details.


        Examples
        --------
        ::

          In [1]: %timeit pass
          10000000 loops, best of 3: 53.3 ns per loop

          In [2]: u = None

          In [3]: %timeit u is None
          10000000 loops, best of 3: 184 ns per loop

          In [4]: %timeit -r 4 u == None
          1000000 loops, best of 4: 242 ns per loop

          In [5]: import time

          In [6]: %timeit -n1 time.sleep(2)
          1 loop, best of 3: 2 s per loop


        The times reported by %timeit will be slightly higher than those
        reported by the timeit.py script when variables are accessed. This is
        due to the fact that %timeit executes the statement in the namespace
        of the shell, compared with timeit.py, which uses a single setup
        statement to import function or create variables. Generally, the bias
        does not matter as long as results from timeit.py are not mixed with
        those from %timeit.")
                        (reparse-symbol indented_block_body) [34781 41873])
                    ("time" function
                       (:parent "dummy"
                        :decorators 
                          ( ("skip_doctest" function (:type "decorator") nil nil)
                            ("needs_local_scope" function (:type "decorator") nil nil)
                            ("line_cell_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [41949 41953])
                            ("line" variable nil (reparse-symbol function_parameters) [41954 41958])
                            ("cell" variable nil (reparse-symbol function_parameters) [41963 41967])
                            ("local_ns" variable nil (reparse-symbol function_parameters) [41974 41982]))                          
                        :documentation "Time execution of a Python statement or expression.

        The CPU and wall clock times are printed, and the value of the
        expression (if any) is returned.  Note that under Win32, system time
        is always reported as 0, since it can not be measured.
        
        This function can be used both as a line and cell magic:

        - In line mode you can time a single-line statement (though multiple
          ones can be chained with using semicolons).

        - In cell mode, you can time the cell body (a directly 
          following statement raises an error).

        This function provides very basic timing functionality.  Use the timeit 
        magic for more control over the measurement.

        Examples
        --------
        ::

          In [1]: %time 2**128
          CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
          Wall time: 0.00
          Out[1]: 340282366920938463463374607431768211456L

          In [2]: n = 1000000

          In [3]: %time sum(range(n))
          CPU times: user 1.20 s, sys: 0.05 s, total: 1.25 s
          Wall time: 1.37
          Out[3]: 499999500000L

          In [4]: %time print 'hello world'
          hello world
          CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
          Wall time: 0.00

          Note that the time needed by Python to compile the given expression
          will be reported if it is more than 0.1s.  In this example, the
          actual exponentiation is done by Python at compilation time, so while
          the expression can take a noticeable amount of time to compute, that
          time is purely due to the compilation:

          In [5]: %time 3**9999;
          CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
          Wall time: 0.00 s

          In [6]: %time 3**999999;
          CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
          Wall time: 0.00 s
          Compiler : 0.78 s
          ")
                        (reparse-symbol indented_block_body) [41878 46181])
                    ("macro" function
                       (:parent "dummy"
                        :decorators 
                          ( ("skip_doctest" function (:type "decorator") nil nil)
                            ("line_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [46230 46234])
                            ("parameter_s" variable nil (reparse-symbol function_parameters) [46236 46247]))                          
                        :documentation "Define a macro for future re-execution. It accepts ranges of history,
        filenames or string objects.

        Usage:\\\\
          %macro [options] name n1-n2 n3-n4 ... n5 .. n6 ...

        Options:

          -r: use 'raw' input.  By default, the 'processed' history is used,
          so that magics are loaded in their transformed version to valid
          Python.  If this option is given, the raw input as typed at the
          command line is used instead.
          
          -q: quiet macro definition.  By default, a tag line is printed 
          to indicate the macro has been created, and then the contents of 
          the macro are printed.  If this option is given, then no printout
          is produced once the macro is created.

        This will define a global variable called `name` which is a string
        made of joining the slices and lines you specify (n1,n2,... numbers
        above) from your input history into a single string. This variable
        acts like an automatic function which re-executes those lines as if
        you had typed them. You just type 'name' at the prompt and the code
        executes.

        The syntax for indicating input ranges is described in %history.

        Note: as a 'hidden' feature, you can also use traditional python slice
        notation, where N:M means numbers N through M-1.

        For example, if your history contains (print using %hist -n )::

          44: x=1
          45: y=3
          46: z=x+y
          47: print x
          48: a=5
          49: print 'x',x,'y',y

        you can create a macro with lines 44 through 47 (included) and line 49
        called my_macro with::

          In [55]: %macro my_macro 44-47 49

        Now, typing `my_macro` (without quotes) will re-execute all this code
        in one pass.

        You don't need to give the line-numbers in order, and any given line
        number can appear multiple times. You can assemble macros with any
        lines from your input history in any order.

        The macro is a simple object which holds its value in an attribute,
        but IPython's display system checks for macros and executes them as
        code instead of printing them when you type their name.

        You can view a macro's contents by explicitly printing it with::

          print macro_name

        ")
                        (reparse-symbol indented_block_body) [46186 49566])
                    ("" code nil (reparse-symbol indented_block_body) [49603 49605])
                    ("" code nil (reparse-symbol indented_block_body) [49635 50100])
                    ("" code nil (reparse-symbol indented_block_body) [50130 50213])
                    ("" code nil (reparse-symbol indented_block_body) [50243 50326])
                    ("" code nil (reparse-symbol indented_block_body) [50356 50456])
                    ("capture" function
                       (:parent "dummy"
                        :decorators 
                          ( ("cell_magic" function (:type "decorator") nil nil))                          
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [50489 50493])
                            ("line" variable nil (reparse-symbol function_parameters) [50495 50499])
                            ("cell" variable nil (reparse-symbol function_parameters) [50501 50505]))                          
                        :documentation "run the cell, capturing stdout, stderr, and IPython's rich display() calls.")
                        (reparse-symbol indented_block_body) [50461 50928]))                  
                :type "class")
                nil [4787 50928])
            ("parse_breakpoint" function (:arguments 
              ( ("text" variable nil (reparse-symbol function_parameters) [50950 50954])
                ("current_file" variable nil (reparse-symbol function_parameters) [50956 50968]))              ) nil [50929 51195])
            ("_format_time" function
               (:documentation "Formats the timespan in a human readable form"
                :arguments 
                  ( ("timespan" variable nil (reparse-symbol function_parameters) [51217 51225])
                    ("precision" variable nil (reparse-symbol function_parameters) [51227 51236]))                  )
                nil [51200 52684]))          
      :file "execution.py"
      :pointmax 52684
      :fsize 52684
      :lastmodtime '(22278 4369 428808 196000)
      :unmatched-syntax '((INDENT_BLOCK 49240 . 49288) (NEWLINE 49239 . 49240) (COLON 49238 . 49239) (TRY 49121 . 49124) (AS 49234 . 49236) (INDENT_BLOCK 23626 . 23779) (NEWLINE 23625 . 23626) (COLON 23624 . 23625) (TRY 23383 . 23386) (AS 23620 . 23622))))
  :file "!usr!local!lib!python2.7!dist-packages!IPython!core!magics!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
